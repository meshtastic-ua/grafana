{"version":3,"sources":["hexUtils.js","varintUtils.js","protobufDecoder.js","protobufPartDecoder.js","ProtobufPart.js","ProtobufDisplay.js","App.js","index.js"],"names":["parseInput","input","normalizedInput","replace","normalizedHexInput","toLowerCase","string","result","char","isHex","Buffer","from","bufferToPrettyHex","buffer","output","v","hex","toString","length","bufferLeToBeHex","BIGINT_1","JSBI","BigInt","BIGINT_2","BufferReader","this","offset","res","shift","byte","RangeError","multiplier","exponentiate","thisByteValue","multiply","add","value","decodeVarint","checkByte","slice","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","savedOffset","TYPES","decodeProto","reader","parts","trySkipGrpcHeader","checkpoint","indexType","parseInt","readVarInt","type","index","readBuffer","push","err","resetToCheckpoint","leftOver","decodeFixed64","floatValue","readDoubleLE","uintValue","intValue","greaterThan","maxLong","subtract","longForComplement","twoComplements","decodeVarintParts","intVal","n","signedIntVal","equal","bitwiseAnd","divide","ProtobufVarintPart","props","map","d","i","key","ProtobufStringPart","decoded","ProtobufFixed64Part","ProtobufFixed32Part","readFloatLE","readInt32LE","readUInt32LE","decodeFixed32","ProtobufPart","part","stringType","typeToString","Table","Row","Cell","getProtobufPart","ProtobufDisplay","celled","Header","HeaderCell","Body","App","useState","hexBuffer","setHexBuffer","urlParams","URLSearchParams","window","location","search","useEffect","onPageLoad","console","log","get","document","readyState","addEventListener","removeEventListener","Container","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.8feb9938.chunk.js","sourcesContent":["export function parseInput(input) {\n  const normalizedInput = input.replace(/\\s/g, \"\");\n  const normalizedHexInput = normalizedInput.replace(/0x/g, \"\").toLowerCase();\n  if (isHex(normalizedHexInput)) {\n    return Buffer.from(normalizedHexInput, \"hex\");\n  } else {\n    return Buffer.from(normalizedInput, \"base64\");\n  }\n}\n\nexport function isHex(string) {\n  let result = true;\n  for (const char of string) {\n    if (!((char >= \"a\" && char <= \"f\") || (char >= \"0\" && char <= \"9\"))) {\n      result = false;\n    }\n  }\n  return result;\n}\n\nexport function bufferToPrettyHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    if (output !== \"\") {\n      output += \" \";\n    }\n\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output += \"0\" + hex;\n    } else {\n      output += hex;\n    }\n  }\n  return output;\n}\n\nexport function bufferLeToBeHex(buffer) {\n  let output = \"\";\n  for (const v of buffer) {\n    const hex = v.toString(16);\n    if (hex.length === 1) {\n      output = \"0\" + hex + output;\n    } else {\n      output = hex + output;\n    }\n  }\n  return output;\n}\n","import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n","import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  STRING: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.STRING) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n\n      parts.push({\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.STRING:\n      return \"string\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n","import JSBI from \"jsbi\";\nimport { bufferLeToBeHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue.toString() });\n  }\n\n  result.push({ type: \"Double\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({ type: \"Int\", value: intVal.toString() });\n\n  const signedIntVal = interpretAsSignedType(intVal);\n  if (signedIntVal !== intVal) {\n    result.push({ type: \"Signed Int\", value: signedIntVal.toString() });\n  }\n  return result;\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n","import React from \"react\";\nimport { Table } from \"semantic-ui-react\";\nimport { decodeProto, TYPES, typeToString } from \"./protobufDecoder\";\nimport {\n  decodeFixed32,\n  decodeFixed64,\n  decodeVarintParts\n} from \"./protobufPartDecoder\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\n\nfunction ProtobufVarintPart(props) {\n  const { value } = props;\n  const decoded = decodeVarintParts(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction ProtobufStringPart(props) {\n  const { value } = props;\n\n  // TODO: Support repeated field\n\n  const decoded = decodeProto(value);\n  if (value.length > 0 && decoded.leftOver.length === 0) {\n    return <ProtobufDisplay value={decoded} />;\n  } else {\n    return value.toString();\n  }\n}\n\nfunction ProtobufFixed64Part(props) {\n  const { value } = props;\n  const decoded = decodeFixed64(value);\n\n  return decoded.map((d, i) => (\n    <span key={i}>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction ProtobufFixed32Part(props) {\n  const { value } = props;\n  const decoded = decodeFixed32(value);\n\n  return decoded.map(d => (\n    <span>\n      As {d.type}: {d.value}\n      <br />\n    </span>\n  ));\n}\n\nfunction getProtobufPart(part) {\n  switch (part.type) {\n    case TYPES.VARINT:\n      return <ProtobufVarintPart value={part.value} />;\n    case TYPES.STRING:\n      return <ProtobufStringPart value={part.value} />;\n    case TYPES.FIXED64:\n      return <ProtobufFixed64Part value={part.value} />;\n    case TYPES.FIXED32:\n      return <ProtobufFixed32Part value={part.value} />;\n    default:\n      return \"Unknown type\";\n  }\n}\n\nfunction ProtobufPart(props) {\n  const { part } = props;\n\n  const stringType = typeToString(part.type);\n\n  return (\n    <Table.Row>\n      <Table.Cell>{part.index}</Table.Cell>\n      <Table.Cell>{stringType}</Table.Cell>\n      <Table.Cell>{getProtobufPart(part)}</Table.Cell>\n    </Table.Row>\n  );\n}\n\nexport default ProtobufPart;\n","import React, { Fragment } from \"react\";\nimport ProtobufPart from \"./ProtobufPart\";\nimport { Table } from \"semantic-ui-react\";\nimport { bufferToPrettyHex } from \"./hexUtils\";\n\nfunction ProtobufDisplay(props) {\n  const { value } = props;\n\n  const parts = value.parts.map((part, i) => {\n    return <ProtobufPart key={i} part={part} />;\n  });\n\n  const leftOver = value.leftOver.length ? (\n    <p>Left over bytes: {bufferToPrettyHex(value.leftOver)}</p>\n  ) : null;\n\n  return (\n    <Fragment>\n      <Table celled>\n        <Table.Header>\n          <Table.Row>\n            <Table.HeaderCell>Field Number</Table.HeaderCell>\n            <Table.HeaderCell>Type</Table.HeaderCell>\n            <Table.HeaderCell>Content</Table.HeaderCell>\n          </Table.Row>\n        </Table.Header>\n\n        <Table.Body>{parts}</Table.Body>\n      </Table>\n      {leftOver}\n    </Fragment>\n  );\n}\n\nexport default ProtobufDisplay;\n","import React, { Fragment, useState, useEffect } from \"react\";\nimport { Container, Divider, Form, Header, TextArea } from \"semantic-ui-react\";\nimport { parseInput, bufferToPrettyHex } from \"./hexUtils\";\nimport \"./App.css\";\nimport ProtobufDisplay from \"./ProtobufDisplay\";\nimport { decodeProto } from \"./protobufDecoder\";\n\n\nfunction App() {\n  const [hex, setHex] = useState(\"\");\n  const [hexBuffer, setHexBuffer] = useState(\"\");\n\n  const urlParams = new URLSearchParams(window.location.search);\n\n  useEffect(() => {\n    const onPageLoad = () => {\n      console.log(urlParams.get('test'));\n      //setHex(urlParams.get('test'));\n      const buffer = parseInput(urlParams.get('payload'));\n      setHexBuffer(buffer);\n    };\n\n    // Check if the page has already loaded\n    if (document.readyState === 'complete') {\n      onPageLoad();\n    } else {\n      window.addEventListener('load', onPageLoad);\n      // Remove the event listener when component unmounts\n      return () => window.removeEventListener('load', onPageLoad);\n    }\n  }, []);\n\n  const onHexChanged = e => {\n    setHex(e.target.value);\n  };\n\n  const onSubmit = () => {\n    const buffer = parseInput(hex);\n\n    // Set pretty hex back to UI\n    setHex(bufferToPrettyHex(buffer));\n\n    // Set to hexBuffer which will be sent to render\n    setHexBuffer(buffer);\n  };\n\n  const result = hexBuffer ? (\n    <Fragment>\n      <ProtobufDisplay value={decodeProto(hexBuffer)} />\n    </Fragment>\n  ) : null;\n\n  return (\n    <Container>\n      {result}\n\n    </Container>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"semantic-ui-css/semantic.min.css\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}